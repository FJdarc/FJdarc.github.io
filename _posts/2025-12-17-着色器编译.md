---
layout: mypost
title: 着色器编译
categories: [OpenGL, Shader]
---

# 着色器编译[原文](https://wikis.khronos.org/opengl/Shader_Compilation)

**着色器编译**指的是将[OpenGL着色语言](https://wikis.khronos.org/opengl/OpenGL_Shading_Language)脚本加载到OpenGL中作为[着色器](https://wikis.khronos.org/opengl/Shader)使用的过程。OpenGL可通过三种方式将着色器文本编译为可用的OpenGL对象，这些编译形式最终都会生成[程序对象](https://wikis.khronos.org/opengl/GLSL_Object#Program_objects)。

**注意**：本文涉及OpenGL 4.x版本功能，例如[细分着色器](https://wikis.khronos.org/opengl/Tessellation)与[计算着色器](https://wikis.khronos.org/opengl/Compute_Shader)。若您使用的是OpenGL 3.x版本，则可忽略相关内容。

---

**目录**
<ul>
  <li>1 <a href="#着色器与程序对象">着色器与程序对象</a>
    <ul>
      <li>1.1 <a href="#着色器对象编译">着色器对象编译</a></li>
      <li>1.2 <a href="#着色器错误处理">着色器错误处理</a></li>
      <li>1.3 <a href="#程序设置">程序设置</a></li>
      <li>1.4 <a href="#链接前准备">链接前准备</a></li>
      <li>1.5 <a href="#程序链接">程序链接</a></li>
      <li>1.6 <a href="#链接与变量">链接与变量</a></li>
      <li>1.7 <a href="#清理">清理</a></li>
      <li>1.8 <a href="#示例">示例</a></li>
    </ul>
  </li>
  <li>2 <a href="#分离程序">分离程序</a>
    <ul>
      <li>2.1 <a href="#程序管线">程序管线</a></li>
      <li>2.2 <a href="#渲染">渲染</a></li>
      <li>2.3 <a href="#统一值与管线">统一值与管线</a></li>
      <li>2.4 <a href="#分离程序示例">分离程序示例</a>
        <ul>
          <li>2.4.1 <a href="#用于顶点和片段着色的两个分离程序">用于顶点和片段着色的两个分离程序</a></li>
          <li>2.4.2 <a href="#混合单阶段与多阶段程序">混合单阶段与多阶段程序</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>3 <a href="#二进制上传">二进制上传</a>
    <ul>
      <li>3.1 <a href="#程序状态">程序状态</a></li>
      <li>3.2 <a href="#二进制格式限制">二进制格式限制</a></li>
    </ul>
  </li>
  <li>4 <a href="#SPIR-V 编译">SPIR-V 编译</a>
    <ul>
      <li>4.1 <a href="#入口点与特化">入口点与特化</a></li>
      <li>4.2 <a href="#链接 SPIR-V">链接 SPIR-V</a></li>
    </ul>
  </li>
  <li>5 <a href="#错误处理">错误处理</a></li>
  <li>6 <a href="#接口匹配">接口匹配</a>
    <ul>
      <li>6.1 <a href="#限定符匹配">限定符匹配</a></li>
      <li>6.2 <a href="#数组接口与着色器阶段">数组接口与着色器阶段</a></li>
      <li>6.3 <a href="#分离程序匹配">分离程序匹配</a></li>
    </ul>
  </li>
  <li>7 <a href="#验证">验证</a>
    <ul>
      <li>7.1 <a href="#管线验证">管线验证</a></li>
    </ul>
  </li>
</ul>

---

## 着色器与程序对象

一个[程序对象](https://wikis.khronos.org/opengl/GLSL_Object#Program_objects)可以包含所有[着色器](https://wikis.khronos.org/opengl/Shader)阶段的可执行代码，这意味着渲染时只需绑定一个程序对象。构建包含多个着色器阶段的程序需要经过两阶段的编译流程。

这种两阶段编译流程类似于C和C++源代码的标准编译/链接模式：首先将C/C++文本输入编译器生成目标文件，随后必须链接一个或多个目标文件才能获得可执行代码。

采用这种程序创建方法时，需先将着色器文本输入编译器生成 _着色器对象_，之后必须链接一个或多个着色器对象才能形成最终的可执行程序对象。

### 着色器对象编译

第一步是针对您计划使用的每个着色器创建着色器对象并对其进行编译。创建着色器对象时，需要调用以下函数：

GLuint [glCreateShader](https://wikis.khronos.org/opengl/GLAPI/glCreateShader)(GLenum shaderType​);

该函数将为 _shaderType_ ​指定的着色器阶段创建一个空的着色器对象。着色器类型必须是`GL_VERTEX_SHADER`、`GL_TESS_CONTROL_SHADER`、 `GL_TESS_EVALUATION_SHADER`、`GL_GEOMETRY_SHADER`、`GL_FRAGMENT_SHADER`或`GL_COMPUTE_SHADER`中的一种。注意，细分控制和细分计算着色器需要OpenGL 4.0（或[ARB_tessellation_shader](https://registry.khronos.org/OpenGL/extensions/ARB/ARB_tessellation_shader.txt)扩展）支持，而计算着色器则需要OpenGL 4.3（或 ARB_compute_shader 扩展）。

创建着色器对象后，需要为其提供表示[GLSL](https://wikis.khronos.org/opengl/OpenGL_Shading_Language)源代码的实际文本字符串。这是通过以下函数完成的：

void [glShaderSource](https://wikis.khronos.org/opengl/GLAPI/glShaderSource)(GLuint shader​, GLsizei count​, const GLchar **string​, const GLint *length​);

此函数接受由`string`​给出的字符串数组，并将其存储到`shader`​中。之前存储的任何字符串都会被清除。`count`表示独立字符串的数量，OpenGL会将这些字符串复制到内部内存中。

着色器在编译时，会将这些字符串视为首尾相连拼接后的完整代码进行编译。这样用户可以方便地从文件中加载着色器的主体部分，同时为某些着色器组添加统一的前置标准代码段。

`length`参数可以是 NULL，也可以是一个包含`count`个整数的数组。这些整数对应`string`数组中各字符串的长度，这允许您使用非以NULL结尾的字符串。如果传入NULL，OpenGL会默认所有字符串都是以NULL结尾的，并按照常规方式计算长度。

将着色器字符串设置到着色器对象后，即可通过以下函数进行编译：

void [glCompileShader](https://wikis.khronos.org/opengl/GLAPI/glCompileShader)(GLuint shader​);

该函数用于编译指定的着色器。

### 着色器错误处理

编译可能成功也可能失败。着色器编译失败不属于[OpenGL错误](https://wikis.khronos.org/opengl/OpenGL_Error)，需要专门进行检查。可通过特定函数调用[glGetShaderiv](https://wikis.khronos.org/opengl/GLAPI/glGetShader)实现：

```c
GLint success = 0;
glGetShaderiv(shader, GL_COMPILE_STATUS, &success);
```

若 _success_ 值为`GL_FALSE`，则表示最近一次编译失败；反之则成功。

着色器编译只有通过/失败两种状态，但了解失败原因通常很有帮助。与大多数编程语言类似，OpenGL会提供文本形式的信息提示。首先需要通过[glGetShaderiv](https://wikis.khronos.org/opengl/GLAPI/glGetShader)查询日志长度：

```c
GLint logSize = 0;
glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logSize);
```

此操作将返回需要分配的字节数（长度值包含空终止符）。获取长度并分配足够内存后，可通过以下函数获取日志信息：

void [glGetShaderInfoLog](https://wikis.khronos.org/opengl/GLAPI/glGetShaderInfoLog)(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog);

参数 _maxLength_ 表示 _infoLog_ 的容量大小，用于告知OpenGL最多可写入的字节数。 _length_ 为返回值，表示实际写入 _infoLog_ 的字节数；若不需此值可传递`NULL`。

---

**着色器编译错误检查示例：**

```c
GLuint shader = glCreateShader(...);

// 获取glShaderSource所需的字符串
glShaderSource(shader, ...);

glCompileShader(shader);

GLint isCompiled = 0;
glGetShaderiv(shader, GL_COMPILE_STATUS, &isCompiled);
if(isCompiled == GL_FALSE)
{
    GLint maxLength = 0;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &maxLength);

    // maxLength包含空终止符
    std::vector<GLchar> errorLog(maxLength);
    glGetShaderInfoLog(shader, maxLength, &maxLength, &errorLog[0]);

    // 以适当方式处理错误日志信息
    // 编译失败时退出
    glDeleteShader(shader); // 防止着色器资源泄漏
    return;
}

// 着色器编译成功
```

### 程序设置

当你成功编译了目标着色器对象后，下一步是将它们链接到一个程序中。这一过程首先通过以下命令创建一个程序对象：

GLuint [glCreateProgram](https://wikis.khronos.org/opengl/GLAPI/glCreateProgram)();

该函数不需要参数。

创建程序后，需要将希望链接的着色器对象附着到该程序上。这通过以下函数完成：

void [glAttachShader](https://wikis.khronos.org/opengl/GLAPI/glAttachShader)(GLuint program​, GLuint shader​);

可以多次调用此函数以附着不同的着色器对象。

注意：允许为[_同一着色阶段_](https://wikis.khronos.org/opengl/Shader)附着多个着色器对象到程序中，这是完全合法的。在链接时，所有代码将被合并。但其中只能有一个着色器对象包含主函数。这种链接方式类似于C/C++程序中链接多个对象文件：如果一个.cpp文件对函数进行了前置声明，便可以调用另一个.cpp文件中的代码。因此，你可以创建函数"库"，供各个着色器选择使用。

建议：虽然这一功能可用，但最好避免使用。它 _通常_ 能正常工作，但由于大多数OpenGL应用程序不采用此方式，该功能的测试覆盖度可能不及OpenGL API的其他部分。因此，这种方式更容易遇到驱动bug。通常建议保持每个着色阶段仅使用一个着色器对象。

### 链接前准备

可以配置一系列影响程序链接过程的参数。这通常涉及与程序相关的接口设置，具体包括：

- [顶点着色器输入属性位置](https://wikis.khronos.org/opengl/Vertex_Attributes)
- [片段着色器输出颜色编号](https://wikis.khronos.org/opengl/Fragment_Shader#Output_buffers)
- [变换反馈输出捕获设置](https://wikis.khronos.org/opengl/Transform_Feedback#Shader_setup)
- [程序分离参数](https://wikis.khronos.org/opengl/Shader_Compilation#Separate_programs)

需要注意的是，这些参数在程序链接完成后将无法修改；如果在链接前未进行设置，则将彻底失去配置机会。

### 程序链接

链接失败可能由多种原因导致，包括但不限于：

- [程序中两个着色器阶段间的匹配无效](https://wikis.khronos.org/opengl/Shader_Compilation#Interface_matching)。
- 违反了不同着色器阶段的限制。部分问题可在编译时发现，但有些必须等到链接时才能检测。
- [某些类型的全局定义](https://wikis.khronos.org/opengl/Shader_Compilation#Linking_and_variables)在两个或多个着色器阶段中重名但定义不同。
- 引用了已声明但未定义的函数。

程序链接失败可以像着色器编译失败那样[被检测和响应](https://wikis.khronos.org/opengl/Shader_Compilation#Error_handling)。

程序一旦成功链接，即可投入使用。

### 链接与变量

通常，不同着色阶段的着色器对象并不相互交互。每个着色阶段的代码都是独立于其他阶段的。它们拥有各自的全局变量、函数等。

但这并非完全如此。某些定义在不同着色阶段之间被视为共享的。具体来说，这包括[统一值](https://wikis.khronos.org/opengl/Uniform_(GLSL))、[缓冲区变量](https://wikis.khronos.org/opengl/Shader_Storage_Buffer_Object)以及缓冲区支持的接口块。

如果其中一个阶段定义了这些对象，另一个阶段可以以相同的名称和 _完全一致的定义_ 来定义同一对象。当这种情况发生时，通过[反射API](https://wikis.khronos.org/opengl/Program_Introspection)只会看到一个统一值/缓冲区变量/接口块。因此，同一程序中的不同着色阶段可以共享统一值变量，从而允许通过一次[glUniform](https://wikis.khronos.org/opengl/GLAPI/glUniform)调用将相同的值设置到两个阶段中。

然而，要实现这一点，定义必须 _完全一致_。这包括成员的顺序、使用的任何用户定义数据结构、数组计数等所有细节。如果不同阶段中的两个定义名称相同但内容不同，则会产生链接错误。

### 清理

在链接操作（无论成功与否）之后，建议将所有的着色器对象从程序中分离。这可以通过以下函数实现：

void [glDetachShader](https://wikis.khronos.org/opengl/GLAPI/glDetachShader)(GLuint program​, GLuint shader​);

其中 _shader_ 必须事先已附加到 _program_ ​。

如果后续不打算在其他程序的链接中使用该特定的着色器对象，可以将其删除。这通过 glDeleteShader 函数实现。需要注意的是，着色器的删除操作会延迟到该着色器对象不再附加到任何程序时才执行。因此，建议在链接完成后分离着色器对象。

### 示例

[顶点着色器](https://wikis.khronos.org/opengl/Vertex_Shader)与[片元着色器](https://wikis.khronos.org/opengl/Fragment_Shader)的完整编译/链接。

```c
// 将着色器源码读入对应的缓冲区
std::string vertexSource = // 获取顶点着色器源码
std::string fragmentSource = // 获取片段着色器源码

// 创建空的顶点着色器句柄
GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);

// 向GL传递顶点着色器源码
// 注意：std::string的.c_str()方法返回以NULL结尾的字符串
const GLchar *source = (const GLchar *)vertexSource.c_str();
glShaderSource(vertexShader, 1, &source, 0);

// 编译顶点着色器
glCompileShader(vertexShader);

GLint isCompiled = 0;
glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &isCompiled);
if(isCompiled == GL_FALSE)
{
    GLint maxLength = 0;
    glGetShaderiv(vertexShader, GL_INFO_LOG_LENGTH, &maxLength);

    // maxLength已包含NULL终止字符
    std::vector<GLchar> infoLog(maxLength);
    glGetShaderInfoLog(vertexShader, maxLength, &maxLength, &infoLog[0]);
    
    // 不再需要此着色器
    glDeleteShader(vertexShader);

    // 可自行处理infoLog中的信息
    
    // 在本简单示例中直接退出
    return;
}

// 创建空的片段着色器句柄
GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);

// 向GL传递片段着色器源码
// 注意：std::string的.c_str()方法返回以NULL结尾的字符串
source = (const GLchar *)fragmentSource.c_str();
glShaderSource(fragmentShader, 1, &source, 0);

// 编译片段着色器
glCompileShader(fragmentShader);

glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &isCompiled);
if (isCompiled == GL_FALSE)
{
    GLint maxLength = 0;
    glGetShaderiv(fragmentShader, GL_INFO_LOG_LENGTH, &maxLength);

    // maxLength已包含NULL终止字符
    std::vector<GLchar> infoLog(maxLength);
    glGetShaderInfoLog(fragmentShader, maxLength, &maxLength, &infoLog[0]);
    
    // 不再需要此着色器
    glDeleteShader(fragmentShader);
    // 两者都需要清理，避免着色器资源泄漏
    glDeleteShader(vertexShader);

    // 可自行处理infoLog中的信息
    
    // 在本简单示例中直接退出
    return;
}

// 顶点与片段着色器编译成功
// 现在将其链接为完整程序
// 获取程序对象
GLuint program = glCreateProgram();

// 将着色器附加到程序
glAttachShader(program, vertexShader);
glAttachShader(program, fragmentShader);

// 链接程序
glLinkProgram(program);

// 注意此处使用glGetProgram*而非glGetShader*
GLint isLinked = 0;
glGetProgramiv(program, GL_LINK_STATUS, (int *)&isLinked);
if (isLinked == GL_FALSE)
{
    GLint maxLength = 0;
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &maxLength);

    // maxLength已包含NULL终止字符
    std::vector<GLchar> infoLog(maxLength);
    glGetProgramInfoLog(program, maxLength, &maxLength, &infoLog[0]);
    
    // 不再需要此程序
    glDeleteProgram(program);
    // 同时清理着色器避免泄漏
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    // 可自行处理infoLog中的信息
    
    // 在本简单示例中直接退出
    return;
}

// 链接成功后始终分离着色器
glDetachShader(program, vertexShader);
glDetachShader(program, fragmentShader);
```

## 分离程序

### 程序管线

### 渲染

### 统一值与管线

### 分离程序示例

#### 用于顶点和片段着色的两个分离程序

#### 混合单阶段与多阶段程序

## 二进制上传

### 程序状态

### 二进制格式限制

## SPIR-V 编译

### 入口点与特化

### 链接 SPIR-V

## 错误处理

## 接口匹配

### 限定符匹配

### 数组接口与着色器阶段

### 分离程序匹配

## 验证

### 管线验证
