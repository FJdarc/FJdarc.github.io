---
layout: mypost
title: 着色器编译
categories: [OpenGL, Shader]
---

# 着色器编译[原文](https://wikis.khronos.org/opengl/Shader_Compilation)

**着色器编译**是指将[OpenGL着色语言](https://wikis.khronos.org/opengl/OpenGL_Shading_Language)脚本加载到OpenGL中用作[着色器](https://wikis.khronos.org/opengl/Shader)的过程。OpenGL提供三种方法将着色器文本编译成可用的OpenGL对象。所有这些编译方式都会生成一个[程序对象](https://wikis.khronos.org/opengl/GLSL_Object#Program_objects)。

注：本文包含对OpenGL 4.x功能的引用，例如[曲面细分着色器](https://wikis.khronos.org/opengl/Tessellation)和[计算着色器](https://wikis.khronos.org/opengl/Compute_Shader)。如果您使用的是OpenGL 3.x，则可以忽略这些引用。

---

**目录**

- [着色器编译原文](#着色器编译原文)
  - [着色器与程序对象](#着色器与程序对象)
    - [着色器对象编译](#着色器对象编译)
    - [着色器错误处理](#着色器错误处理)
    - [程序设置](#程序设置)
    - [链接前准备](#链接前准备)
    - [程序链接](#程序链接)
    - [链接与变量](#链接与变量)
    - [清理](#清理)
    - [示例](#示例)
  - [分离程序](#分离程序)
    - [程序管线](#程序管线)
    - [渲染](#渲染)
    - [统一变量与管线](#统一变量与管线)
    - [分离程序示例](#分离程序示例)
      - [用于顶点和片段着色的两个分离程序](#用于顶点和片段着色的两个分离程序)
      - [混合单阶段与多阶段程序](#混合单阶段与多阶段程序)
  - [二进制上传](#二进制上传)
    - [程序状态](#程序状态)
    - [二进制格式限制](#二进制格式限制)
  - [SPIR-V编译](#spir-v编译)
    - [入口点与特化](#入口点与特化)
    - [链接SPIR-V](#链接spir-v)
  - [错误处理](#错误处理)
  - [接口匹配](#接口匹配)
    - [限定符匹配](#限定符匹配)
    - [数组接口与着色器阶段](#数组接口与着色器阶段)
    - [分离程序匹配](#分离程序匹配)
  - [验证](#验证)
    - [管线验证](#管线验证)

---

## 着色器与程序对象

一个[程序对象](https://wikis.khronos.org/opengl/GLSL_Object#Program_objects)可以包含所有[着色器](https://wikis.khronos.org/opengl/Shader)阶段的可执行代码，这意味着渲染时只需绑定一个程序对象。构建包含多个着色器阶段的程序需要经过两阶段的编译流程。

这种两阶段编译流程类似于C和C++源代码的标准编译/链接模式：首先将C/C++文本输入编译器生成目标文件，随后必须链接一个或多个目标文件才能获得可执行代码。

采用这种程序创建方法时，需先将着色器文本输入编译器生成 _着色器对象_，之后必须链接一个或多个着色器对象才能形成最终的可执行程序对象。

### 着色器对象编译

第一步是针对您计划使用的每个着色器创建着色器对象并对其进行编译。创建着色器对象时，需要调用以下函数：

GLuint [glCreateShader](https://wikis.khronos.org/opengl/GLAPI/glCreateShader)(GLenum shaderType​);

该函数将为 _shaderType_ ​指定的着色器阶段创建一个空的着色器对象。着色器类型必须是`GL_VERTEX_SHADER`、`GL_TESS_CONTROL_SHADER`、 `GL_TESS_EVALUATION_SHADER`、`GL_GEOMETRY_SHADER`、`GL_FRAGMENT_SHADER`或`GL_COMPUTE_SHADER`中的一种。注意，细分控制和细分计算着色器需要OpenGL 4.0（或[ARB_tessellation_shader](https://registry.khronos.org/OpenGL/extensions/ARB/ARB_tessellation_shader.txt)扩展）支持，而计算着色器则需要OpenGL 4.3（或 ARB_compute_shader 扩展）。

创建着色器对象后，需要为其提供表示[GLSL](https://wikis.khronos.org/opengl/OpenGL_Shading_Language)源代码的实际文本字符串。这是通过以下函数完成的：

void [glShaderSource](https://wikis.khronos.org/opengl/GLAPI/glShaderSource)(GLuint shader​, GLsizei count​, const GLchar **string​, const GLint *length​);

此函数接受由`string`​给出的字符串数组，并将其存储到`shader`​中。之前存储的任何字符串都会被清除。`count`表示独立字符串的数量，OpenGL会将这些字符串复制到内部内存中。

着色器在编译时，会将这些字符串视为首尾相连拼接后的完整代码进行编译。这样用户可以方便地从文件中加载着色器的主体部分，同时为某些着色器组添加统一的前置标准代码段。

`length`参数可以是 NULL，也可以是一个包含`count`个整数的数组。这些整数对应`string`数组中各字符串的长度，这允许您使用非以NULL结尾的字符串。如果传入NULL，OpenGL会默认所有字符串都是以NULL结尾的，并按照常规方式计算长度。

将着色器字符串设置到着色器对象后，即可通过以下函数进行编译：

void [glCompileShader](https://wikis.khronos.org/opengl/GLAPI/glCompileShader)(GLuint shader​);

该函数用于编译指定的着色器。

### 着色器错误处理

编译可能成功也可能失败。着色器编译失败不属于[OpenGL错误](https://wikis.khronos.org/opengl/OpenGL_Error)，需要专门进行检查。可通过特定函数调用[glGetShaderiv](https://wikis.khronos.org/opengl/GLAPI/glGetShader)实现：

GLint success = 0;
glGetShaderiv(shader, GL_COMPILE_STATUS, &success);

若 _success_ 值为`GL_FALSE`，则表示最近一次编译失败；反之则成功。

着色器编译只有通过/失败两种状态，但了解失败原因通常很有帮助。与大多数编程语言类似，OpenGL会提供文本形式的信息提示。首先需要通过[glGetShaderiv](https://wikis.khronos.org/opengl/GLAPI/glGetShader)查询日志长度：

GLint logSize = 0;
glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logSize);

此操作将返回需要分配的字节数（长度值包含空终止符）。获取长度并分配足够内存后，可通过以下函数获取日志信息：

void [glGetShaderInfoLog](https://wikis.khronos.org/opengl/GLAPI/glGetShaderInfoLog)(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog);

参数 _maxLength_ 表示 _infoLog_ 的容量大小，用于告知OpenGL最多可写入的字节数。 _length_ 为返回值，表示实际写入 _infoLog_ 的字节数；若不需此值可传递`NULL`。

---

**着色器编译错误检查示例：**

```c
GLuint shader = glCreateShader(...);

// 获取glShaderSource所需的字符串
glShaderSource(shader, ...);

glCompileShader(shader);

GLint isCompiled = 0;
glGetShaderiv(shader, GL_COMPILE_STATUS, &isCompiled);
if(isCompiled == GL_FALSE)
{
    GLint maxLength = 0;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &maxLength);

    // maxLength包含空终止符
    std::vector<GLchar> errorLog(maxLength);
    glGetShaderInfoLog(shader, maxLength, &maxLength, &errorLog[0]);

    // 以适当方式处理错误日志信息
    // 编译失败时退出
    glDeleteShader(shader); // 防止着色器资源泄漏
    return;
}

// 着色器编译成功
```

### 程序设置

当你成功编译了目标着色器对象后，下一步是将它们链接到一个程序中。这一过程首先通过以下命令创建一个程序对象：

GLuint [glCreateProgram](https://wikis.khronos.org/opengl/GLAPI/glCreateProgram)();

该函数不需要参数。

创建程序后，需要将希望链接的着色器对象附着到该程序上。这通过以下函数完成：

void [glAttachShader](https://wikis.khronos.org/opengl/GLAPI/glAttachShader)(GLuint program​, GLuint shader​);

可以多次调用此函数以附着不同的着色器对象。

**注意**：允许为[_同一着色阶段_](https://wikis.khronos.org/opengl/Shader)附着多个着色器对象到程序中，这是完全合法的。在链接时，所有代码将被合并。但其中只能有一个着色器对象包含主函数。这种链接方式类似于C/C++程序中链接多个对象文件：如果一个.cpp文件对函数进行了前置声明，便可以调用另一个.cpp文件中的代码。因此，你可以创建函数"库"，供各个着色器选择使用。

**建议**：虽然这一功能可用，但最好避免使用。它 _通常_ 能正常工作，但由于大多数OpenGL应用程序不采用此方式，该功能的测试覆盖度可能不及OpenGL API的其他部分。因此，这种方式更容易遇到驱动bug。通常建议保持每个着色阶段仅使用一个着色器对象。

### 链接前准备

可以配置一系列影响程序链接过程的参数。这通常涉及与程序相关的接口设置，具体包括：

- [顶点着色器输入属性位置](https://wikis.khronos.org/opengl/Vertex_Attributes)
- [片段着色器输出颜色编号](https://wikis.khronos.org/opengl/Fragment_Shader#Output_buffers)
- [变换反馈输出捕获设置](https://wikis.khronos.org/opengl/Transform_Feedback#Shader_setup)
- [程序分离参数](https://wikis.khronos.org/opengl/Shader_Compilation#Separate_programs)

需要注意的是，这些参数在程序链接完成后将无法修改；如果在链接前未进行设置，则将彻底失去配置机会。

### 程序链接

链接失败可能由多种原因导致，包括但不限于：

- [程序中两个着色器阶段间的匹配无效](https://wikis.khronos.org/opengl/Shader_Compilation#Interface_matching)。
- 违反了不同着色器阶段的限制。部分问题可在编译时发现，但有些必须等到链接时才能检测。
- [某些类型的全局定义](https://wikis.khronos.org/opengl/Shader_Compilation#Linking_and_variables)在两个或多个着色器阶段中重名但定义不同。
- 引用了已声明但未定义的函数。

程序链接失败可以像着色器编译失败那样[被检测和响应](https://wikis.khronos.org/opengl/Shader_Compilation#Error_handling)。

程序一旦成功链接，即可投入使用。

### 链接与变量

通常，不同着色阶段的着色器对象并不相互交互。每个着色阶段的代码都是独立于其他阶段的。它们拥有各自的全局变量、函数等。

但这并非完全如此。某些定义在不同着色阶段之间被视为共享的。具体来说，这包括[统一值](https://wikis.khronos.org/opengl/Uniform_(GLSL))、[缓冲区变量](https://wikis.khronos.org/opengl/Shader_Storage_Buffer_Object)以及缓冲区支持的接口块。

如果其中一个阶段定义了这些对象，另一个阶段可以以相同的名称和 _完全一致的定义_ 来定义同一对象。当这种情况发生时，通过[反射API](https://wikis.khronos.org/opengl/Program_Introspection)只会看到一个统一值/缓冲区变量/接口块。因此，同一程序中的不同着色阶段可以共享统一值变量，从而允许通过一次[glUniform](https://wikis.khronos.org/opengl/GLAPI/glUniform)调用将相同的值设置到两个阶段中。

然而，要实现这一点，定义必须 _完全一致_。这包括成员的顺序、使用的任何用户定义数据结构、数组计数等所有细节。如果不同阶段中的两个定义名称相同但内容不同，则会产生链接错误。

### 清理

在链接操作（无论成功与否）之后，建议将所有的着色器对象从程序中分离。这可以通过以下函数实现：

void [glDetachShader](https://wikis.khronos.org/opengl/GLAPI/glDetachShader)(GLuint program​, GLuint shader​);

其中 _shader_ 必须事先已附加到 _program_ ​。

如果后续不打算在其他程序的链接中使用该特定的着色器对象，可以将其删除。这通过 glDeleteShader 函数实现。需要注意的是，着色器的删除操作会延迟到该着色器对象不再附加到任何程序时才执行。因此，建议在链接完成后分离着色器对象。

### 示例

[顶点着色器](https://wikis.khronos.org/opengl/Vertex_Shader)与[片元着色器](https://wikis.khronos.org/opengl/Fragment_Shader)的完整编译/链接。

```c
// 将着色器源码读入对应的缓冲区
std::string vertexSource = // 获取顶点着色器源码
std::string fragmentSource = // 获取片段着色器源码

// 创建空的顶点着色器句柄
GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);

// 向GL传递顶点着色器源码
// 注意：std::string的.c_str()方法返回以NULL结尾的字符串
const GLchar *source = (const GLchar *)vertexSource.c_str();
glShaderSource(vertexShader, 1, &source, 0);

// 编译顶点着色器
glCompileShader(vertexShader);

GLint isCompiled = 0;
glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &isCompiled);
if(isCompiled == GL_FALSE)
{
    GLint maxLength = 0;
    glGetShaderiv(vertexShader, GL_INFO_LOG_LENGTH, &maxLength);

    // maxLength已包含NULL终止字符
    std::vector<GLchar> infoLog(maxLength);
    glGetShaderInfoLog(vertexShader, maxLength, &maxLength, &infoLog[0]);
    
    // 不再需要此着色器
    glDeleteShader(vertexShader);

    // 可自行处理infoLog中的信息
    
    // 在本简单示例中直接退出
    return;
}

// 创建空的片段着色器句柄
GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);

// 向GL传递片段着色器源码
// 注意：std::string的.c_str()方法返回以NULL结尾的字符串
source = (const GLchar *)fragmentSource.c_str();
glShaderSource(fragmentShader, 1, &source, 0);

// 编译片段着色器
glCompileShader(fragmentShader);

glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &isCompiled);
if (isCompiled == GL_FALSE)
{
    GLint maxLength = 0;
    glGetShaderiv(fragmentShader, GL_INFO_LOG_LENGTH, &maxLength);

    // maxLength已包含NULL终止字符
    std::vector<GLchar> infoLog(maxLength);
    glGetShaderInfoLog(fragmentShader, maxLength, &maxLength, &infoLog[0]);
    
    // 不再需要此着色器
    glDeleteShader(fragmentShader);
    // 两者都需要清理，避免着色器资源泄漏
    glDeleteShader(vertexShader);

    // 可自行处理infoLog中的信息
    
    // 在本简单示例中直接退出
    return;
}

// 顶点与片段着色器编译成功
// 现在将其链接为完整程序
// 获取程序对象
GLuint program = glCreateProgram();

// 将着色器附加到程序
glAttachShader(program, vertexShader);
glAttachShader(program, fragmentShader);

// 链接程序
glLinkProgram(program);

// 注意此处使用glGetProgram*而非glGetShader*
GLint isLinked = 0;
glGetProgramiv(program, GL_LINK_STATUS, (int *)&isLinked);
if (isLinked == GL_FALSE)
{
    GLint maxLength = 0;
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &maxLength);

    // maxLength已包含NULL终止字符
    std::vector<GLchar> infoLog(maxLength);
    glGetProgramInfoLog(program, maxLength, &maxLength, &infoLog[0]);
    
    // 不再需要此程序
    glDeleteProgram(program);
    // 同时清理着色器避免泄漏
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    // 可自行处理infoLog中的信息
    
    // 在本简单示例中直接退出
    return;
}

// 链接成功后始终分离着色器
glDetachShader(program, vertexShader);
glDetachShader(program, fragmentShader);
```

## 分离程序

分离着色器对象
- 核心版本     4.6
- 核心起始版本 4.1
- 核心ARB扩展  [ARB_separate_shader_objects](https://registry.khronos.org/OpenGL/extensions/ARB/ARB_separate_shader_objects.txt)

一个程序对象可以包含多个着色器阶段的代码。而[glUseProgram](https://wikis.khronos.org/opengl/GLAPI/glUseProgram)函数仅接受单个程序，因此一次只能使用一个程序进行渲染。这意味着在链接后无法动态混合匹配不同着色器阶段的代码。着色器对象并非程序；它们仅包含编译后的代码片段，而非完整可用的程序。

然而，有一种方法可以实现此功能。这需要对上述模型进行两处调整：一是程序的创建方式，二是其使用方法。

为了允许使用多个程序（每个程序仅提供部分着色器阶段代码），我们首先需要特殊地创建程序。为了表明某个程序对象旨在与此分离程序模型一起使用，必须[在链接前设置该程序的参数](https://wikis.khronos.org/opengl/Shader_Compilation#Before_linking)。具体操作如下：

glProgramParameter(program, GL_PROGRAM_SEPARABLE, GL_TRUE);

**注意**：同样，此操作必须在程序链接之前完成。

创建可分离程序还有另一种方法。这代表了一种常见用例：从单组着色器源创建程序，该源仅提供单个着色器阶段的代码。实现此功能的函数是：

GLuint [glCreateShaderProgramv](https://wikis.khronos.org/opengl/GLAPI/glCreateShaderProgram)(GLenum type​, GLsizei count​, const char **strings​);

该函数的作用等同于：获取 _count_​ 和 _strings_​ 字符串，从中创建指定 _type_​ 着色器类型的着色器对象，然后将该着色器对象链接到带有`GL_PROGRAM_SEPARABLE`参数的程序中，最后分离并删除着色器对象。

此过程可能失败，就像编译或链接可能失败一样。因此，程序信息日志可能包含编译错误和链接错误。
**注意**：[glCreateShaderProgramv](https://wikis.khronos.org/opengl/GLAPI/glCreateShaderProgramv)将返回程序对象的名称或零——无论着色器编译或链接期间是否发生错误！返回值为零仅表示着色器对象或程序对象无法创建。如果返回非零值，您仍需要检查程序信息日志以确保编译和链接成功！此外，该函数本身在某些条件下可能会生成错误，同样会导致返回零。

**警告**：使用可分离程序链接着色器时，如果尝试使用[gl_PerVertex接口块](https://wikis.khronos.org/opengl/Built-in_Variable_(GLSL))内定义的任何变量，则着色器必须重新声明该接口块。

可分离程序允许将多个阶段的着色器链接到同一程序中。虽然最好仅使用单一阶段的着色器（因为使用可分离程序的主要目的是能够自由混合匹配），但并非强制要求。然而，如果两个阶段链接到同一程序中，由于[管道验证规则](https://wikis.khronos.org/opengl/Shader_Compilation#Validation)，您将无法在这两个阶段之间插入另一个程序。

**注意**：[glCreateShaderProgramv](https://wikis.khronos.org/opengl/GLAPI/glCreateShaderProgram)是一个非常有用的工具，但它有一个主要缺点：无法在生成程序中设置任何[链接前参数](https://wikis.khronos.org/opengl/Shader_Compilation#Before_linking)。大多数链接前参数可以直接在着色器中设置，但在可分离程序被允许后的多个版本中，变换反馈参数无法在着色器中设置。[此功能最终被加入核心GL](https://wikis.khronos.org/opengl/Transform_Feedback#In-shader_specification)，但除非使用OpenGL 4.4或[ARB_enhanced_layouts](https://registry.khronos.org/OpenGL/extensions/ARB/ARB_enhanced_layouts.txt)，否则如果需要可分离程序和变换反馈，则必须使用常规的两阶段着色器编译流程。

### 程序管线

创建可分离程序只是第一步，您还必须改变程序的使用方式。

要使用多个可分离程序，首先需要将它们组装成名为**程序管道**的[OpenGL对象](https://wikis.khronos.org/opengl/OpenGL_Object)类型。与程序对象或着色器对象不同，程序管道遵循标准的[OpenGL对象](https://wikis.khronos.org/opengl/OpenGL_Object)模式。因此，存在[glGenProgramPipelines]()(https://wikis.khronos.org/opengl/GLAPI/glGenProgramPipelines)函数用于生成新的管道名称，[glDeleteProgramPipelines](https://wikis.khronos.org/opengl/GLAPI/glDeleteProgramPipelines)用于删除管道，以及[glBindProgramPipeline](https://wikis.khronos.org/opengl/GLAPI/glBindProgramPipeline)用于将其绑定到上下文。程序管道对象没有目标，因此最后一个函数仅接收要绑定的管道参数。

与[采样器对象](https://wikis.khronos.org/opengl/Sampler_Object)类似，程序管道对象仅应在准备用它们进行渲染（或通过它们设置uniform变量，[如下所述](https://wikis.khronos.org/opengl/Shader_Compilation#Uniforms_and_pipelines)）时绑定。程序管道对象中唯一的状态是包含各着色阶段代码的程序列表。该状态通过以下函数设置：

void [glUseProgramStages](https://wikis.khronos.org/opengl/GLAPI/glUseProgramStages)(GLuint pipeline, GLbitfield stages, GLuint program);

指定的 _pipeline_ 将从给定的 _program_ 中获取由位字段 _stages_ 定义的着色器阶段代码。 _stages_ 位字段决定 _program_ 中的哪些着色阶段将为管道中的对应着色阶段提供代码。这些位可以是以下枚举值的组合：`GL_VERTEX_SHADER_BIT`、`GL_TESS_CONTROL_SHADER_BIT`、`GL_TESS_EVALUATION_SHADER_BIT`、`GL_GEOMETRY_SHADER_BIT`、`GL_FRAGMENT_SHADER_BIT`和`GL_COMPUTE_SHADER_BIT`。位字段也可以是`GL_ALL_SHADER_BITS`，这等效于所有上述位的组合。如果`program`在`stages`指定的每个阶段都有可用代码，那么管道将使用这些代码。如果`program`为0，则会从管道中清除指定的阶段。

`program`必须为0或一个可分离程序。

程序管道对象是[容器对象](https://wikis.khronos.org/opengl/OpenGL_Object#Container_object)，因此它们不能在[多个OpenGL上下文之间共享](https://wikis.khronos.org/opengl/OpenGL_Object#Object_Sharing)。

### 渲染

当您拥有了一个包含所有所需独立阶段的可运作程序管线后，即可通过它进行渲染。为此，您首先必须使用[glBindProgramPipeline](https://wikis.khronos.org/opengl/GLAPI/glBindProgramPipeline)函数来绑定程序管线。

**警告**：[glUseProgram](https://wikis.khronos.org/opengl/GLAPI/glUseProgram)**会覆盖**[glBindProgramPipeline](https://wikis.khronos.org/opengl/GLAPI/glBindProgramPipeline)的作用。也就是说，如果当前已有一个程序被使用且同时绑定了一个程序管线，那么所有渲染操作都将使用当前活跃的程序，而非管线中的程序。因此，请务必确保已经调用了[glUseProgram(0)](https://wikis.khronos.org/opengl/GLAPI/glUseProgram)。

绑定管线之后，您便可以[像平常一样使用这些阶段进行渲染](https://wikis.khronos.org/opengl/Vertex_Rendering)，或[派遣计算任务](https://wikis.khronos.org/opengl/Compute_Shader#Dispatch)。程序管线也可以进行[验证](https://wikis.khronos.org/opengl/Shader_Compilation#Validation)。

### 统一变量与管线
 
**建议**：以下解释一种极为复杂的使用[glBindProgramPipeline](https://wikis.khronos.org/opengl/GLAPI/glBindProgramPipeline)的方式，允许用户为管线中的某个程序设置uniform状态。 _强烈_ 建议忽略本节内容。相反，在编写新代码时，请使用[glProgramUniform](https://wikis.khronos.org/opengl/GLAPI/glProgramUniform)直接将uniform设置到程序中，而无需绑定或使用该程序。仅当您 _必须_ 与某些在绑定到上下文的程序上设置uniform的函数保持向后兼容时，才使用以下机制。

[glUniform](https://wikis.khronos.org/opengl/GLAPI/glUniform)用于更改当前使用程序的uniform状态。然而，在分离程序和程序管线的情况下，“当前使用程序”的定义更为复杂。其工作原理如下。

OpenGL首先检查当前通过[glUseProgram](wikis.khronos.org/opengl/GLAPI/glUseProgram)设置的程序（您可以使用此函数绑定可分离程序）。如果通过此函数绑定了程序，则该程序即为当前使用程序。如果未通过此函数设置程序（即执行glUseProgram(0)），则进入下一步。

检查当前绑定的程序管线。程序管线具有活动程序的概念。程序管线对象的活动程序即为“当前使用程序”（同样，仅在[glUseProgram](https://wikis.khronos.org/opengl/GLAPI/glUseProgram)未使用程序时适用）。

管线的活动程序通过以下函数设置：

void [glActiveShaderProgram](https://wikis.khronos.org/opengl/GLAPI/glActiveShaderProgram)(GLuint pipeline​, GLuint program​);

 _program_ ​必须是一个有效且成功链接的程序对象。 _值不得为零_ ；一旦将活动程序设置到管线对象上，就无法取消设置。  
**注意**：尽管看似不合理，但 _program_ ​不必附加到 _pipeline_ ​上即可生效。管线可以将一个完全不相关的程序作为其活动程序。

### 分离程序示例

以下示例描述了在使用可分离程序时可能出现的几种场景。第一个示例旨在展示使用[glCreateShaderProgramv](https://wikis.khronos.org/opengl/GLAPI/glCreateShaderProgramv)函数时固有的简洁性；第二个示例则演示如何处理多阶段程序，并执行在创建单阶段可分离程序时无法完成的预链接工作。

注意：为简洁起见，以下代码假设源码字符串能够成功完成编译和链接，且所有相关资源均成功创建。但在实际编码中，强烈建议进行适当的错误检查，并获取着色器/程序/管线日志！至少应像之前整体程序示例中所示范的那样进行基本检查。

#### 用于顶点和片段着色的两个分离程序

创建两个可分离的程序，一个包含顶点着色器，一个包含片段着色器。

```c
// 分别从单个源字符串（vertSrc 和 fragSrc）创建两个可分离的程序对象
GLuint vertProg = glCreateShaderProgramv(GL_VERTEX_SHADER, 1, &vertSrc);
GLuint fragProg = glCreateShaderProgramv(GL_FRAGMENT_SHADER, 1, &fragSrc);

// 必须在此处进行错误检查！

// 生成程序管道并将程序附加到对应阶段
glGenProgramPipelines(1, &pipeline);
glUseProgramStages(pipeline, GL_VERTEX_SHADER_BIT, vertProg);
glUseProgramStages(pipeline, GL_FRAGMENT_SHADER_BIT, fragProg);

// 查询并设置uniform变量
GLint colorLoc = glGetUniformLocation(fragProg, "Color");
glProgramUniform4f(fragProg, colorLoc, 1.f, 0.f, 0.f, 1.f);
```

#### 混合单阶段与多阶段程序

创建独立的程序，其中某些着色阶段被直接链接在一起。

```c
// 创建两个程序：一个仅包含顶点着色器，
// 另一个同时包含几何着色器和片段着色器阶段
GLuint vertexProgram   = glCreateProgram();
GLuint geomFragProgram = glCreateProgram();

// 声明程序为可分离状态——这一点至关重要！
glProgramParameteri(vertexProgram  , GL_PROGRAM_SEPARABLE, GL_TRUE);
glProgramParameteri(geomFragProgram, GL_PROGRAM_SEPARABLE, GL_TRUE);

// 常规流程：生成并编译着色器对象
GLuint vertShader  = glCreateShader(GL_VERTEX_SHADER);
GLuint geomShader  = glCreateShader(GL_GEOMETRY_SHADER);
GLuint fragShader  = glCreateShader(GL_FRAGMENT_SHADER);

glShaderSource(vertShader, 1, &vertSrc, NULL);
glShaderSource(geomShader, 1, &geomSrc, NULL);
glShaderSource(fragShader, 1, &fragSrc, NULL);

glCompileShader(vertShader);
glCompileShader(geomShader);
glCompileShader(fragShader);

// 将着色器附加到对应的程序
glAttachShader(vertexProgram  , vertShader);
glAttachShader(geomFragProgram, geomShader);
glAttachShader(geomFragProgram, fragShader);

// 执行预链接步骤
glBindAttribLocation(vertexProgram    , 0, "Position");
glBindFragDataLocation(geomFragProgram, 0, "FragColor");

// 链接程序
glLinkProgram(vertexProgram);
glLinkProgram(geomFragProgram);

// 分离并删除着色器对象
glDetachShader(vertexProgram, vertShader);
glDeleteShader(vertShader);

glDetachShader(geomFragProgram, geomShader);
glDetachShader(geomFragProgram, fragShader);
glDeleteShader(geomShader);
glDeleteShader(fragShader);

// 生成程序管道
glGenProgramPipelines(1, &pipeline);

// 将第一个程序附加到顶点着色阶段，
// 将第二个程序附加到几何着色和片段着色阶段
glUseProgramStages(pipeline, GL_VERTEX_SHADER_BIT, vertexProgram);
glUseProgramStages(pipeline, GL_GEOMETRY_SHADER_BIT | GL_FRAGMENT_SHADER_BIT, geomFragProgram);
```

## 二进制上传

分离着色器对象
- 核心版本     4.6
- 核心起始版本 4.1
- 核心ARB扩展  [ARB_get_program_binary](http://www.opengl.org/registry/specs/ARB/get_program_binary.txt)

编译和链接着色器，无论使用何种方法，都可能耗时较长。着色器数量越多，此过程所需时间越长。能够缓存程序链接结果通常很有用，这样重新加载缓存的程序可以快得多。

这通过一组调用实现。给定一个成功链接的程序，用户可以获取代表该程序的一段二进制数据（采用特定格式）。此过程的第一步是通过调用[glGetProgram](https://wikis.khronos.org/opengl/GLAPI/glGetProgram)并传入`GL_PROGRAM_BINARY_LENGTH`参数来获取数据长度。获取长度后，即可通过以下函数获取实际二进制数据：

void [glGetProgramBinary](https://wikis.khronos.org/opengl/GLAPI/glGetProgramBinary)(GLuint program​, GLsizei bufsize​, GLsizei *length​, GLenum *binaryFormat​, void *binary​);

其中 _bufsize_ ​是 _binary_ ​中可用的最大字节数。 _length_ ​是输出值，表示复制到 _binary_ ​中的字节数；它是可选参数，可以为NULL。 _binaryFormat_ ​是指定二进制数据格式的输出值，此为必填项，必须与实际二进制数据一起存储。

获得格式和二进制数据后，即可用这些二进制数据创建新的程序对象。这通过以下函数完成：

void [glProgramBinary](https://wikis.khronos.org/opengl/GLAPI/glProgramBinary)(GLuint program​, GLenum binaryFormat​, const void *binary​, GLsizei length​);

此函数将 _binary_ 数据（长度由 _length​_ 指定）按给定 _binaryFormat_ ​格式上传至 _program_ ​。若上传成功，则相当于对 _program_ ​执行了成功的链接调用。

若 _binaryFormat_ ​不是受支持的格式，此函数可能失败。可通过[glGetIntegerv](https://wikis.khronos.org/opengl/GLAPI/glGet)查询允许的格式：使用`GL_NUM_PROGRAM_BINARY_FORMATS`获取格式数量，`GL_PROGRAM_BINARY_FORMATS`获取具体格式列表。函数也可能因其他原因失败；无法[保证二进制数据一定能被加载](https://wikis.khronos.org/opengl/Shader_Compilation#Binary_limitations)。

### 程序状态

程序对象包含特定状态。程序二进制文件仅封装了链接成功时的程序状态。这意味着所有uniform都会被重置为其默认值（着色器内指定的值或0）。顶点属性和片元着色器输出将具有已分配的值，变换反馈数据、接口块绑定等也是如此。

如果[glProgramBinary](https://wikis.khronos.org/opengl/GLAPI/glProgramBinary)调用成功，它应生成一个与原始程序对象在链接完成后完全相同的程序对象。

如果原始程序是[可分离](https://wikis.khronos.org/opengl/Shader_Compilation#Separate_programs)的，那么从二进制文件构建的程序也将是可分离的。反之亦然。

### 二进制格式限制

程序的二进制格式并非用于传输。期望不同硬件厂商接受相同的二进制格式是不合理的。期望同一厂商的不同硬件接受相同的二进制格式也是不合理的。

实际上，即使是在同一台机器上，你也不能指望缓存的版本能够正常工作。数据缓存和重新加载之间的驱动程序更新可能会改变可接受的二进制格式。因此，[glProgramBinary](wikis.khronos.org/opengl/GLAPI/glProgramBinary)可能会频繁失败。如果你使用此功能，必须为当二进制格式被拒绝时提供备用方案来创建着色器。

## SPIR-V编译

分离着色器对象
- 核心版本 4.6
- 核心起始版本 4.6
- 核心ARB扩展 [ARB_spirv_extensions](http://www.opengl.org/registry/specs/ARB/spirv_extensions.txt)
- ARB扩展 [ARB_gl_spirv](https://registry.khronos.org/OpenGL/extensions/ARB/ARB_gl_spirv.txt)

[SPIR-V](https://wikis.khronos.org/opengl/SPIR-V)的编译模型与**GLSL**相似，但具有一些独特特性。

与GLSL类似，SPIR-V使用着色器对象和程序对象。由于SPIR-V是二进制格式，需通过着色器二进制API将SPIR-V着色器加载到着色器对象中：
void [glShaderBinary](https://wikis.khronos.org/opengl/GLAPI/glShaderBinary)(GLsizei count​, const GLuint *shaders​, GLenum binaryFormat​, const void *binary​, GLsizei length​);

 _shaders_ ​是长度为 _count_ ​的数组，包含先前创建的着色器对象，SPIR-V数据将被加载至这些对象中。因此该函数可将同一份SPIR-V源代码加载到多个着色器对象中。

SPIR-V 具有特定的 _binaryFormat_ ：枚举值`GL_SHADER_BINARY_FORMAT_SPIR_V`。 _binary_ 参数即为待加载的 SPIR-V 本身，其字节长度为 length。根据规范要求，该二进制数据必须包含完整的 SPIR-V 内容（含头部信息）。

调用此函数将覆盖先前通过 [glShaderSource](https://wikis.khronos.org/opengl/GLAPI/glShaderSource) 或 [glShaderBinary](https://wikis.khronos.org/opengl/GLAPI/glShaderBinary) 加载的着色器。若向程序加载非SPIR-V二进制文件或GLSL源代码字符串，将导致其不再包含SPIR-V代码。

当着色器对象加载了SPIR-V二进制文件时，该对象的特性将略有变化。调用[glGetShaderiv(shader, GL_SPIR_V_BINARY)](https://wikis.khronos.org/opengl/GLAPI/glGetShader)将返回GL_TRUE。

### 入口点与特化

SPIR-V 与 GLSL 相似，但存在若干差异。其中两点差异尤为重要。

  1. 单个 SPIR-V 文件可包含多个着色器阶段的函数入口点，甚至支持不同类型的入口点。
  2. SPIR-V 引入了“特化常量”概念：用户可在 SPIR-V 编译为最终形式前提供这些参数。

使用 SPIR-V 着色器对象前，必须指定要使用的入口点，并为该入口点使用的特化常量提供数值。此操作通过单一函数实现：
void glSpecializeShader(GLuint shader​, const GLchar *pEntryPoint​, GLuint numSpecializationConstants​, const GLuint *pConstantIndex​, const GLuint *pConstantValue​);

_pEntryPoint_ ​是该SPIR-V着色器对象将使用的入口点的字符串名称。 _pConstantIndex​_ 和 _pConstantValue_ ​是包含每个特化常量索引及其对应值的数组，其长度为 _numSpecializationConstants_ ​。未被 _pConstantIndex​_ 引用的特化常量将采用SPIR-V着色器中指定的默认值。

SPIR-V着色器的特化过程类似于编译GLSL着色器。因此，若该函数执行成功，着色器对象的编译状态即为`GL_TRUE`。若特化失败，着色器信息日志将记录失败原因，并触发[OpenGL错误](https://wikis.khronos.org/opengl/OpenGL_Error)。

pEntryPoint 必须指定有效的入口点名称。同时，该入口点的“执行模型”（SPIR-V术语中的“[着色器阶段](https://wikis.khronos.org/opengl/Shader#Stages)”）必须与创建着色器对象时使用的阶段相匹配。若pConstantIndex引用了SPIR-V二进制文件未使用的特化常量索引，也会导致特化失败。特化失败时，着色器信息日志将相应更新。

SPIR-V着色器一旦完成特化便不可重新特化。但可通过重新加载SPIR-V二进制数据实现再次特化。

### 链接SPIR-V

经过特化的SPIR-V着色器对象可用于链接程序（可分离或不可分离）。若在同一程序中链接多个着色器对象，则必须全部采用SPIR-V着色器，或完全不使用SPIR-V着色器。程序中不可将SPIR-V着色器与非SPIR-V着色器混合链接。

另请注意，SPIR-V着色器必须具备入口点。因此同一处理阶段的SPIR-V模块无法相互链接。每个SPIR-V着色器对象必须完整提供其模块所需的全部代码。

您可在同一管道对象中，将基于SPIR-V着色器构建的可分离程序与非SPIR-V着色器共同使用。

## 错误处理

程序链接可能因多种原因失败。无论是创建[独立程序](https://wikis.khronos.org/opengl/Shader_Compilation#Separate_programs)时，还是将[程序二进制数据](https://wikis.khronos.org/opengl/Shader_Compilation#Binary_upload)加载到程序对象时，都会发生链接过程。所有这些过程都可能失败。

注意：使用[glCreateShaderProgram](https://wikis.khronos.org/opengl/GLAPI/glCreateShaderProgram)相当于同时执行着色器编译和程序链接操作。由于它同时执行这两项操作，因此可能会遇到编译器或链接器错误。但此函数仅返回程序对象，因此编译器类型的错误将通过以下API作为链接器错误报告。

要判断链接是否失败，可调用[glGetProgramiv](https://wikis.khronos.org/opengl/GLAPI/glGetProgram)：

```c
GLint isLinked = 0;
glGetProgramiv(program, GL_LINK_STATUS, &isLinked);
```

若`isLinked`为`GL_FALSE`（即零值），则说明该程序最近一次的链接操作失败（或该程序从未被链接过）。否则表示链接成功。

程序链接只有通过/失败两种状态，但了解失败原因通常很有帮助。与大多数编程语言类似，链接器错误会以文本消息形式提供。OpenGL允许查询包含这些错误信息的日志。为此，首先需要再次使用[glGetProgramiv](https://wikis.khronos.org/opengl/GLAPI/glGetProgram)查询日志长度：

```c
GLint maxLength = 0;
glGetProgramiv(program, GL_INFO_LOG_LENGTH, &maxLength);
```

此操作会告知需要分配多少字节的空间；该长度已包含NULL终止符。获取长度并分配足够内存后，可使用以下函数获取日志：

void [glGetProgramInfoLog](https://wikis.khronos.org/opengl/GLAPI/glGetProgramInfoLog)(GLuint program​, GLsizei maxLength​, GLsizei *length​, GLchar *infoLog​);

其中 _maxLength_ 是 _infoLog_ 的缓冲区大小，用于告知OpenGL最多可写入多少字节至 _infoLog_ 。 _length_ 是返回值，表示实际写入 _infoLog_ 的字节数；若不需此值可传入NULL。

---

**程序链接错误检查示例**

```c
GLuint program = glCreateProgram();

// 按需附加着色器
glAttachShader(program, ...);
...

// 链接程序
glLinkProgram(program);

GLint isLinked = 0;
glGetProgramiv(program, GL_LINK_STATUS, &isLinked);
if (isLinked == GL_FALSE)
{
    GLint maxLength = 0;
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &maxLength);

    // maxLength已包含NULL终止符
    std::vector<GLchar> infoLog(maxLength);
    glGetProgramInfoLog(program, maxLength, &maxLength, &infoLog[0]);

    // 程序现已无效，将其删除
    glDeleteProgram(program);

    // 以适当方式提供错误日志信息
    // 退出并返回失败状态
    return;
}
```

## 接口匹配

着色器在不同阶段包含输入与输出变量。大多数着色器输出的值会直接传递至后续着色器阶段的输入变量中，这些变量间的匹配需遵循特定规则。

当将多个着色器阶段直接链接在一起时，这些规则会在程序链接阶段进行检查。因此，阶段间的接口不匹配会导致链接错误。然而，在可分离程序构成的管线中，不同程序间的接口匹配只能在运行时使用管线时才进行检查。

直接链接多个着色器阶段要求前一阶段的所有输出都被下一活动阶段的输入所消耗，反之亦然，否则将引发链接错误。但可分离程序间并不要求严格的完全匹配，这种非精确匹配的结果[如下文所述](https://wikis.khronos.org/opengl/Shader_Compilation#Separate_program_matching)。

输出与输入变量可存在于[接口块](https://wikis.khronos.org/opengl/Interface_Block_(GLSL))中，也可以作为独立的松散变量存在。二者的匹配规则有所不同。

当满足以下条件时，输出接口块与输入接口块相匹配：

- 接口块名称必须一致。请注意：块名称与实例名称不同。块名称位于声明顶部；实例名称位于底部。不同着色器阶段中的实例名称可以不同。
- 输出块的成员必须与输入块的成员完全相同。这意味着每个块中的成员必须满足以下条件：
  - 声明顺序一致。
  - 成员名称相同。
  - 类型完全匹配（若为数组，则元素数量必须一致）。
  - 类型限定符匹配（具体规则[如下所述](https://wikis.khronos.org/opengl/Shader_Compilation#Qualifier_matching)）。

对于松散变量，当满足以下条件时，输出变量与输入变量相匹配：

- 两个变量表示同一接口。这通过按以下顺序检查确定（前者优先级高于后者）：
  - 若两个变量均设置了等效的 layout(location) 属性。
  - 若两个变量名称相同（且均未设置 layout(location) 限定符）。
- 两个变量的类型相匹配（[在可分离程序中](https://wikis.khronos.org/opengl/Shader_Compilation#Separate_program_matching)允许存在轻微的不匹配情况）。若为数组，则元素数量必须一致。
- 类型限定符相匹配（具体规则[如下所述](https://wikis.khronos.org/opengl/Shader_Compilation#Qualifier_matching)）。

### 限定符匹配

在同一阶段输出变量与后续阶段同名输入变量之间的[类型限定符](https://wikis.khronos.org/opengl/Type_Qualifier_(GLSL))必须匹配。除以下情况外，这些匹配要求完全一致：

- 显而易见的存储限定符（in/out）无需匹配
- [精度限定符](https://wikis.khronos.org/opengl/Type_Qualifier_(GLSL)#Precision_qualifiers)
- [invariant限定符](https://wikis.khronos.org/opengl/Type_Qualifier_(GLSL)#Invariance_qualifiers)
- [precise限定符](https://wikis.khronos.org/opengl/Type_Qualifier_(GLSL)#Precise_qualifiers)
- 若支持GLSL 4.30或更高版本，则[插值限定符](https://wikis.khronos.org/opengl/Type_Qualifier_(GLSL)#Interpolation_qualifiers)（包括centroid与sample）无需匹配。在GLSL 4.30中，插值方式完全由[片元着色器](https://wikis.khronos.org/opengl/Fragment_Shader)指定的限定符决定（即使片元着色器中未显式声明限定符，系统也将采用默认设置）。

所有其他限定符在命名相同的变量间必须保持完全匹配。  

### 数组接口与着色器阶段

某些着色器阶段会自动将其输入或输出聚合成数组形式。例如，[几何着色器](https://wikis.khronos.org/opengl/Geometry_Shader)接收元素数组，其中每个数组索引代表一个顶点。[曲面细分控制着色器](https://wikis.khronos.org/opengl/Tessellation_Control_Shader)则接收输入数组并写入输出数组，每个索引同样对应一个顶点。

为确定接口匹配，此类聚合型输入或输出被视为非数组（若接口变量本身是[包含数组的数组](https://wikis.khronos.org/opengl/Data_Type_(GLSL)#Arrays_of_arrays)，则忽略第一层数组维度）。曲面细分控制/求值着色器中带有patch限定符的输出/输入不会以数组形式聚合，因此不适用此规则。若创建数组形式的补丁变量，则控制着色器与求值着色器中的数组索引必须保持一致。

### 分离程序匹配

允许分离程序存在非精确匹配（即并非每个输出都被每个输入消耗的情况）。

然而，只有当使用了松散变量且这些变量采用layout(location)限定符时，不匹配才会导致定义明确的行为。在非精确匹配的情况下，所有其他输入变量都将具有未定义的值，这包括根据常规规则匹配但未使用layout(location)限定符的输入变量。若匹配不精确，则仅那些通过layout(location)限定符实现匹配的变量会正常运作。

因此：

```c
// 输出着色器
out vec4 one;                 // 输出变量 one（未指定位置）
out vec3 two;                 // 输出变量 two（未指定位置）
layout(location = 1) out vec3 three;  // 指定位置 1 的输出变量 three
layout(location = 2) out vec4 four;   // 指定位置 2 的输出变量 four
out OutBlock                    // 输出块 OutBlock
{
  vec4 five;                    // 块成员 five
};

// 输入着色器 1
layout(location = 1) in vec3 val1; // 与输出变量 `three` 匹配（位置 1，类型一致）。
in ivec4 one;                      // 类型不匹配（输出为 vec4，输入为 ivec4）。值未定义。
in vec3 two;                       // 由于存在其他不匹配，该输入值未定义。
in OutBlock                        // 输入块 OutBlock
{
  vec4 five;                       // 同样因存在其他不匹配，该输入值未定义。
};
```

此外，当使用 layout(location) 限定符时，变量类型不必完全匹配。如果输出变量是向量类型，且其组件数量多于对应的输入变量（注意：这里的对应关系基于 layout(location) 而非名称），同时两者的基本组件类型一致（例如 ivec3 的基本类型是 int），且该基本类型不是 double，那么这两个变量将被视为匹配。输出写入的多余组件将被忽略。因此，以下情况可能实现匹配：

```c
// 输出着色器
layout(location = 5) out vec4 vals;

// 输入着色器
layout(location = 5) in float foo; // 从 `vals` 中获取 .x 分量
```

## 验证

**待办事项：此部分需要填写。**

在渲染操作中，程序对象或程序管线对象必须有效才能被使用。虽然这种有效性的检查会尽可能在链接时完成，但部分验证依赖于当前OpenGL状态，因此仍需在运行时进行检测。对于程序管线而言，不可分割程序原本在链接时需要检查的有效性项目（如接口匹配），现在必须在运行时验证。

程序或管线对象的有效性可通过以下函数随时检查：

以下是程序对象验证的规则：

### 管线验证

管道对象验证还需检查以下内容：
