---
layout: mypost
title: 着色器编译
categories: [OpenGL, Shader]
---

# 着色器编译[原文](https://wikis.khronos.org/opengl/Shader_Compilation)

**着色器编译**指的是将[OpenGL着色语言](https://wikis.khronos.org/opengl/OpenGL_Shading_Language)脚本加载到OpenGL中作为[着色器](https://wikis.khronos.org/opengl/Shader)使用的过程。OpenGL可通过三种方式将着色器文本编译为可用的OpenGL对象，这些编译形式最终都会生成[程序对象](https://wikis.khronos.org/opengl/GLSL_Object#Program_objects)。

**注意**：本文涉及OpenGL 4.x版本功能，例如[细分着色器](https://wikis.khronos.org/opengl/Tessellation)与[计算着色器](https://wikis.khronos.org/opengl/Compute_Shader)。若您使用的是OpenGL 3.x版本，则可忽略相关内容。

---

**目录**
<ul>
  <li>1 <a href="#着色器与程序对象">着色器与程序对象</a>
    <ul>
      <li>1.1 <a href="#着色器对象编译">着色器对象编译</a></li>
      <li>1.2 <a href="#着色器错误处理">着色器错误处理</a></li>
      <li>1.3 <a href="#程序设置">程序设置</a></li>
      <li>1.4 <a href="#链接前准备">链接前准备</a></li>
      <li>1.5 <a href="#程序链接">程序链接</a></li>
      <li>1.6 <a href="#链接与变量">链接与变量</a></li>
      <li>1.7 <a href="#清理">清理</a></li>
      <li>1.8 <a href="#示例">示例</a></li>
    </ul>
  </li>
  <li>2 <a href="#分离程序">分离程序</a>
    <ul>
      <li>2.1 <a href="#程序管线">程序管线</a></li>
      <li>2.2 <a href="#渲染">渲染</a></li>
      <li>2.3 <a href="#统一值与管线">统一值与管线</a></li>
      <li>2.4 <a href="#分离程序示例">分离程序示例</a>
        <ul>
          <li>2.4.1 <a href="#用于顶点和片段着色的两个分离程序">用于顶点和片段着色的两个分离程序</a></li>
          <li>2.4.2 <a href="#混合单阶段与多阶段程序">混合单阶段与多阶段程序</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>3 <a href="#二进制上传">二进制上传</a>
    <ul>
      <li>3.1 <a href="#程序状态">程序状态</a></li>
      <li>3.2 <a href="#二进制格式限制">二进制格式限制</a></li>
    </ul>
  </li>
  <li>4 <a href="#SPIR-V 编译">SPIR-V 编译</a>
    <ul>
      <li>4.1 <a href="#入口点与特化">入口点与特化</a></li>
      <li>4.2 <a href="#链接 SPIR-V">链接 SPIR-V</a></li>
    </ul>
  </li>
  <li>5 <a href="#错误处理">错误处理</a></li>
  <li>6 <a href="#接口匹配">接口匹配</a>
    <ul>
      <li>6.1 <a href="#限定符匹配">限定符匹配</a></li>
      <li>6.2 <a href="#数组接口与着色器阶段">数组接口与着色器阶段</a></li>
      <li>6.3 <a href="#分离程序匹配">分离程序匹配</a></li>
    </ul>
  </li>
  <li>7 <a href="#验证">验证</a>
    <ul>
      <li>7.1 <a href="#管线验证">管线验证</a></li>
    </ul>
  </li>
</ul>

---

## 着色器与程序对象

### 着色器对象编译

### 着色器错误处理

### 程序设置

### 链接前准备

### 程序链接

### 链接与变量

### 清理

### 示例

[顶点着色器](https://wikis.khronos.org/opengl/Vertex_Shader)与[片元着色器](https://wikis.khronos.org/opengl/Fragment_Shader)的完整编译/链接。

```c++
// 将着色器源码读入对应的缓冲区
std::string vertexSource = // 获取顶点着色器源码
std::string fragmentSource = // 获取片段着色器源码

// 创建空的顶点着色器句柄
GLuint vertexShader = glCreateShader(GL_VERTEX_SHADER);

// 向GL传递顶点着色器源码
// 注意：std::string的.c_str()方法返回以NULL结尾的字符串
const GLchar *source = (const GLchar *)vertexSource.c_str();
glShaderSource(vertexShader, 1, &source, 0);

// 编译顶点着色器
glCompileShader(vertexShader);

GLint isCompiled = 0;
glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &isCompiled);
if(isCompiled == GL_FALSE)
{
    GLint maxLength = 0;
    glGetShaderiv(vertexShader, GL_INFO_LOG_LENGTH, &maxLength);

    // maxLength已包含NULL终止字符
    std::vector<GLchar> infoLog(maxLength);
    glGetShaderInfoLog(vertexShader, maxLength, &maxLength, &infoLog[0]);
    
    // 不再需要此着色器
    glDeleteShader(vertexShader);

    // 可自行处理infoLog中的信息
    
    // 在本简单示例中直接退出
    return;
}

// 创建空的片段着色器句柄
GLuint fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);

// 向GL传递片段着色器源码
// 注意：std::string的.c_str()方法返回以NULL结尾的字符串
source = (const GLchar *)fragmentSource.c_str();
glShaderSource(fragmentShader, 1, &source, 0);

// 编译片段着色器
glCompileShader(fragmentShader);

glGetShaderiv(fragmentShader, GL_COMPILE_STATUS, &isCompiled);
if (isCompiled == GL_FALSE)
{
    GLint maxLength = 0;
    glGetShaderiv(fragmentShader, GL_INFO_LOG_LENGTH, &maxLength);

    // maxLength已包含NULL终止字符
    std::vector<GLchar> infoLog(maxLength);
    glGetShaderInfoLog(fragmentShader, maxLength, &maxLength, &infoLog[0]);
    
    // 不再需要此着色器
    glDeleteShader(fragmentShader);
    // 两者都需要清理，避免着色器资源泄漏
    glDeleteShader(vertexShader);

    // 可自行处理infoLog中的信息
    
    // 在本简单示例中直接退出
    return;
}

// 顶点与片段着色器编译成功
// 现在将其链接为完整程序
// 获取程序对象
GLuint program = glCreateProgram();

// 将着色器附加到程序
glAttachShader(program, vertexShader);
glAttachShader(program, fragmentShader);

// 链接程序
glLinkProgram(program);

// 注意此处使用glGetProgram*而非glGetShader*
GLint isLinked = 0;
glGetProgramiv(program, GL_LINK_STATUS, (int *)&isLinked);
if (isLinked == GL_FALSE)
{
    GLint maxLength = 0;
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &maxLength);

    // maxLength已包含NULL终止字符
    std::vector<GLchar> infoLog(maxLength);
    glGetProgramInfoLog(program, maxLength, &maxLength, &infoLog[0]);
    
    // 不再需要此程序
    glDeleteProgram(program);
    // 同时清理着色器避免泄漏
    glDeleteShader(vertexShader);
    glDeleteShader(fragmentShader);

    // 可自行处理infoLog中的信息
    
    // 在本简单示例中直接退出
    return;
}

// 链接成功后始终分离着色器
glDetachShader(program, vertexShader);
glDetachShader(program, fragmentShader);
```

## 分离程序

### 程序管线

### 渲染

### 统一值与管线

### 分离程序示例

#### 用于顶点和片段着色的两个分离程序

#### 混合单阶段与多阶段程序

## 二进制上传

### 程序状态

### 二进制格式限制

## SPIR-V 编译

### 入口点与特化

### 链接 SPIR-V

## 错误处理

## 接口匹配

### 限定符匹配

### 数组接口与着色器阶段

### 分离程序匹配

## 验证

### 管线验证
